<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Knowledge_Vault]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>site-lib/media/favicon.png</url><title>Knowledge_Vault</title><link/></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Fri, 03 Oct 2025 16:48:48 GMT</lastBuildDate><atom:link href="site-lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Fri, 03 Oct 2025 16:48:48 GMT</pubDate><ttl>60</ttl><dc:creator/><item><title><![CDATA[01 Interconnect Fabric]]></title><description><![CDATA[The Interconnect Built in <a data-href="00 Basic 1 to 1 Interconnect" href="root/digital-design/interconnect/00-basic-1-to-1-interconnect.html" class="internal-link" target="_self" rel="noopener nofollow">00 Basic 1 to 1 Interconnect</a> only accommodates 1 Requestor and completer.Interconnect Protocol Vs Interconnect Fabric
The interconnect protocol affects the types of transactions that can occur between a given requestor–completer pair, whereas the interconnect fabric’s implementation affects the communication patterns that can occur among different requestor–completer pairs.
The naive method would be making many Requestor interfaces for each completer but that would incur a lot of logic and chip area. As you increase the number of requestors, things get problematic as you would need a complete bipartite graph topology between requestors and completers, this does not scale well.<br><img alt="Pasted image 20251003185851.png" src="images/pasted-image-20251003185851.png" target="_self">Thus we need something to Multiplex requestor signals to the needed completer. To do this we need to introduce an interconnect Fabric.<br><img alt="Pasted image 20251003190142.png" src="images/pasted-image-20251003190142.png" target="_self">This is an elegant solution that simply lets requestor address the completers using an ADDR signal to the interconnect fabric. This is called the address space. All interconnects contain an address decoder which takes care of address resolution, this is just a bunch of comparators.<br><img alt="Pasted image 20251003190823.png" src="images/pasted-image-20251003190823.png" target="_self">This arrangement of address decoder is very bulky, and introduces a long critical path reducing the interconnects maximum clock frequency. We can implement better address mapping to simplify the logic of address decoders.Lets propose only putting completers's address space on power of 2 addresses.<br><img alt="Pasted image 20251003191255.png" src="images/pasted-image-20251003191255.png" target="_self">This way, we can simplify our logic, and instead of using comparators for both the upper bound and lower bound of the address space, we can just compare the most significant bit eliminating the need for a comparator and a subtractor:<br><img alt="Pasted image 20251003191451.png" src="images/pasted-image-20251003191451.png" target="_self">]]></description><link>root/digital-design/interconnect/01-interconnect-fabric.html</link><guid isPermaLink="false">Root/Digital Design/Interconnect/01 Interconnect Fabric.md</guid><pubDate>Fri, 03 Oct 2025 16:16:50 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20251003191451]]></title><description><![CDATA[<img src="images/pasted-image-20251003191451.png" target="_self">]]></description><link>images/pasted-image-20251003191451.html</link><guid isPermaLink="false">Images/Pasted image 20251003191451.png</guid><pubDate>Fri, 03 Oct 2025 16:14:51 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20251003191255]]></title><description><![CDATA[<img src="images/pasted-image-20251003191255.png" target="_self">]]></description><link>images/pasted-image-20251003191255.html</link><guid isPermaLink="false">Images/Pasted image 20251003191255.png</guid><pubDate>Fri, 03 Oct 2025 16:12:55 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20251003190823]]></title><description><![CDATA[<img src="images/pasted-image-20251003190823.png" target="_self">]]></description><link>images/pasted-image-20251003190823.html</link><guid isPermaLink="false">Images/Pasted image 20251003190823.png</guid><pubDate>Fri, 03 Oct 2025 16:08:23 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[00 Basic 1 to 1 Interconnect]]></title><description><![CDATA[
This is more or less a summarization of Chapter 4, of Arm Fundamentals of SoC textbook Requestor &amp; Completer
The Component that is Requesting a resource/computation from another component, the completer, which completes this request.
ARM SoC: Single Word Transaction
The simplest form of transaction that we need an interconnect protocol to support is the movement of a single word from a requestor to a completer, that is, a single-word write transaction.
To Support Single Word Write Transaction we can simply add
The WR signal and the WRDATA are recieved on the same rising edge.
To Support Single Word Write Transaction we can simply add
The RD signal is received at rising edge 0 cycle 0, then the RDDATA on the next rising edge
<img alt="Pasted image 20251002163252.png" src="images/pasted-image-20251002163252.png" target="_self">Assumption &amp; disadvantages This assumes the completer can read/execute the request every clock cycle (1) We’ve assumed until now that there is only is one location, that is, only one register, in the completer (2) Asynchronous Reads
nothing prevents an interconnect protocol from permitting read data to be returned during cycle C (and, in fact, many protocols do allow this); however, this would imply that the overall read operation is asynchronous and we have stated that the interconnect we are building is synchronous.
<br><img alt="Pasted image 20251002164032.png" src="images/pasted-image-20251002164032.png" target="_self">A Major Disadvantage with the current interconnect that its support for back-to-back rapid transaction is lack-luster and leaves clock cycles to be optimized.
In the general case of a completer with an N-cycle end-to-end read latency, the maximum data throughput will be: To Mitigate this we can add a LENGTH Control Signal to signal to the completer how much data is given to it to write/read.<br><img alt="Pasted image 20251002164741.png" src="images/pasted-image-20251002164741.png" target="_self"><br><img alt="Pasted image 20251002164822.png" src="images/pasted-image-20251002164822.png" target="_self"><br>We Know <a data-tooltip-position="top" aria-label="^DW2" data-href="#^DW2" href="#^DW2" class="internal-link" target="_self" rel="noopener nofollow">Assumption (1)</a> is not true as the completer may need to process the request for many clock cycles.Terminiology
The mechanism through which a completer communicates its unavailability to a requestor is referred to as backpressure and a requestor waiting on a completer’s acknowledgement in this context is said to be stalled
To realize this feature, all we need is to implement a READY signal.
A transaction starts only when WR/RD and READY are both asserted in the same clock cycle.
Avoid Infinite Requestor Stalling
if a requestor wants to start a transaction, then it should assert its control signals and keep them asserted until the completer’s READY signal is asserted, Two Design Decesions are employed here: the requestor must not check the READY signal before deciding to assert its control signals because otherwise the completer may never know of the requestor’s intention to start a transaction
transactions cannot be interrupted once started because a requestor cannot deassert its control signals early, and all data words must be transmitted for both entities to acknowledge the transaction has finished. <br><img alt="Pasted image 20251002190522.png" src="images/pasted-image-20251002190522.png" target="_self">
Notice That the Completer Asserts/Deasserts the READY signal for each data write B C &amp; D.
Reading from completors may also incur many clock cycles, There needs to be a control signal that registers that the data within the RDDATA bus is valid.For a read transaction, the RD signal does not convey the validity of the RDDATA bus, but rather the validity of the control signals relevant to starting a transaction (ADDR, LENGTH). We need an additional completer-to-requestor signal to convey the validity of the RDDATA bus.
So RDDATAVALID is born: once completer fetches data, the RDDATAVALID, is asserted.
<br><img alt="Pasted image 20251002192210.png" src="images/pasted-image-20251002192210.png" target="_self"><br>Why would a Requestor Exert Backpressure on Completers? after all, shouldn’t a requestor know what it wants to write to the completer before initiating a burst transaction? This is the case when only a small amount of data needs transmitting, but if large amounts of data are involved some requestors may not know the extent of the payload they want to transmit at the outset. A common example would be a requestor reading from a FIFO.
<img alt="Pasted image 20251003182710.png" src="images/pasted-image-20251003182710.png" target="_self">
To Implement Requestor to Completer Backpressure, you can do this by deasserting the WR signal then asserting it again.<br><img alt="Pasted image 20251003183017.png" src="images/pasted-image-20251003183017.png" target="_self">We cannot Approach it as Write Transaction
Asserting RD when all of the data words from the previous transaction have not yet been received would be equivalent to the requestor telling the completer it wanted to start a new transaction as soon as the current one had terminated
Some protocols allow requestors to signal for completers future transactions, this done by giving the Completer a notice so that it can ensure its internal buffers accommodate the burst transaction.We are not those protocols so we will add a new signal RDDATAREADY which when deasserted by the requester, the requester can stall itself, and the completer will not assert new data in RDDATA bus unless RDDATAREADY is asserted again.<br><img alt="Pasted image 20251003184041.png" src="images/pasted-image-20251003184041.png" target="_self"><br>Next <a data-href="01 Interconnect Fabric" href="root/digital-design/interconnect/01-interconnect-fabric.html" class="internal-link" target="_self" rel="noopener nofollow">01 Interconnect Fabric</a>]]></description><link>root/digital-design/interconnect/00-basic-1-to-1-interconnect.html</link><guid isPermaLink="false">Root/Digital Design/Interconnect/00 Basic 1 to 1 Interconnect.md</guid><pubDate>Fri, 03 Oct 2025 16:02:59 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20251003190142]]></title><description><![CDATA[<img src="images/pasted-image-20251003190142.png" target="_self">]]></description><link>images/pasted-image-20251003190142.html</link><guid isPermaLink="false">Images/Pasted image 20251003190142.png</guid><pubDate>Fri, 03 Oct 2025 16:01:42 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20251003190025]]></title><description><![CDATA[<img src="images/pasted-image-20251003190025.png" target="_self">]]></description><link>images/pasted-image-20251003190025.html</link><guid isPermaLink="false">Images/Pasted image 20251003190025.png</guid><pubDate>Fri, 03 Oct 2025 16:00:25 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20251003185851]]></title><description><![CDATA[<img src="images/pasted-image-20251003185851.png" target="_self">]]></description><link>images/pasted-image-20251003185851.html</link><guid isPermaLink="false">Images/Pasted image 20251003185851.png</guid><pubDate>Fri, 03 Oct 2025 15:58:51 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20251003184213]]></title><description><![CDATA[<img src="images/pasted-image-20251003184213.png" target="_self">]]></description><link>images/pasted-image-20251003184213.html</link><guid isPermaLink="false">Images/Pasted image 20251003184213.png</guid><pubDate>Fri, 03 Oct 2025 15:42:13 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20251003184041]]></title><description><![CDATA[<img src="images/pasted-image-20251003184041.png" target="_self">]]></description><link>images/pasted-image-20251003184041.html</link><guid isPermaLink="false">Images/Pasted image 20251003184041.png</guid><pubDate>Fri, 03 Oct 2025 15:40:41 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20251003183017]]></title><description><![CDATA[<img src="images/pasted-image-20251003183017.png" target="_self">]]></description><link>images/pasted-image-20251003183017.html</link><guid isPermaLink="false">Images/Pasted image 20251003183017.png</guid><pubDate>Fri, 03 Oct 2025 15:30:17 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20251003182710]]></title><description><![CDATA[<img src="images/pasted-image-20251003182710.png" target="_self">]]></description><link>images/pasted-image-20251003182710.html</link><guid isPermaLink="false">Images/Pasted image 20251003182710.png</guid><pubDate>Fri, 03 Oct 2025 15:27:10 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[02 AHB-Lite Protocol]]></title><link>root/digital-design/interconnect/02-ahb-lite-protocol.html</link><guid isPermaLink="false">Root/Digital Design/Interconnect/02 AHB-Lite Protocol.md</guid><pubDate>Thu, 02 Oct 2025 13:06:44 GMT</pubDate></item><item><title><![CDATA[00 Basic Interconnect]]></title><description><![CDATA[
This is more or less a summarization of Chapter 4, of Arm Fundamentals of SoC textbook Requestor &amp; Completer
The Component that is Requesting a resource/computation from another component, the completer, which completes this request.
ARM SoC: Single Word Transaction
The simplest form of transaction that we need an interconnect protocol to support is the movement of a single word from a requestor to a completer, that is, a single-word write transaction.
To Support Single Word Write Transaction we can simply add
The WR signal and the WRDATA are recieved on the same rising edge.
To Support Single Word Write Transaction we can simply add
The RD signal is received at rising edge 0 cycle 0, then the RDDATA on the next rising edge
<img alt="Pasted image 20251002163252.png" src="images/pasted-image-20251002163252.png" target="_self">Assumption &amp; disadvantages This assumes the completer can read/execute the request every clock cycle (1) We’ve assumed until now that there is only is one location, that is, only one register, in the completer (2) Asynchronous Reads
nothing prevents an interconnect protocol from permitting read data to be returned during cycle C (and, in fact, many protocols do allow this); however, this would imply that the overall read operation is asynchronous and we have stated that the interconnect we are building is synchronous.
<br><img alt="Pasted image 20251002164032.png" src="images/pasted-image-20251002164032.png" target="_self">A Major Disadvantage with the current interconnect that its support for back-to-back rapid transaction is lack-luster and leaves clock cycles to be optimized.
In the general case of a completer with an N-cycle end-to-end read latency, the maximum data throughput will be: To Mitigate this we can add a LENGTH Control Signal to signal to the completer how much data is given to it to write/read.<br><img alt="Pasted image 20251002164741.png" src="images/pasted-image-20251002164741.png" target="_self"><br><img alt="Pasted image 20251002164822.png" src="images/pasted-image-20251002164822.png" target="_self"><br>We Know <a data-tooltip-position="top" aria-label="^DW2" data-href="#^DW2" href="#^DW2" class="internal-link" target="_self" rel="noopener nofollow">Assumption (1)</a> is not true as the completer may need to process the request for many clock cycles.Terminiology
The mechanism through which a completer communicates its unavailability to a requestor is referred to as backpressure and a requestor waiting on a completer’s acknowledgement in this context is said to be stalled
To realize this feature, all we need is to implement a READY signal.
A transaction starts only when WR/RD and READY are both asserted in the same clock cycle.
Avoid Infinite Requestor Stalling
if a requestor wants to start a transaction, then it should assert its control signals and keep them asserted until the completer’s READY signal is asserted, Two Design Decesions are employed here: the requestor must not check the READY signal before deciding to assert its control signals because otherwise the completer may never know of the requestor’s intention to start a transaction
transactions cannot be interrupted once started because a requestor cannot deassert its control signals early, and all data words must be transmitted for both entities to acknowledge the transaction has finished. <br><img alt="Pasted image 20251002190522.png" src="images/pasted-image-20251002190522.png" target="_self">
Notice That the Completer Asserts/Deasserts the READY signal for each data write B C &amp; D.
Reading from completors may also incur many clock cycles, There needs to be a control signal that registers that the data within the RDDATA bus is valid.For a read transaction, the RD signal does not convey the validity of the RDDATA bus, but rather the validity of the control signals relevant to starting a transaction (ADDR, LENGTH). We need an additional completer-to-requestor signal to convey the validity of the RDDATA bus.
So RDDATAVALID is born: once completer fetches data, the RDDATAVALID, is asserted.
<br><img alt="Pasted image 20251002192210.png" src="images/pasted-image-20251002192210.png" target="_self"><br>Next <a data-href="01 AHB-Lite Protocol" href="root/digital-design/interconnect/01-ahb-lite-protocol.html" class="internal-link" target="_self" rel="noopener nofollow">01 AHB-Lite Protocol</a>]]></description><link>root/digital-design/interconnect/00-basic-interconnect.html</link><guid isPermaLink="false">Root/Digital Design/Interconnect/00 Basic Interconnect.md</guid><pubDate>Fri, 03 Oct 2025 14:47:51 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20251002192210]]></title><description><![CDATA[<img src="images/pasted-image-20251002192210.png" target="_self">]]></description><link>images/pasted-image-20251002192210.html</link><guid isPermaLink="false">Images/Pasted image 20251002192210.png</guid><pubDate>Thu, 02 Oct 2025 16:22:10 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20251002190522]]></title><description><![CDATA[<img src="images/pasted-image-20251002190522.png" target="_self">]]></description><link>images/pasted-image-20251002190522.html</link><guid isPermaLink="false">Images/Pasted image 20251002190522.png</guid><pubDate>Thu, 02 Oct 2025 16:05:22 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20251002164822]]></title><description><![CDATA[<img src="images/pasted-image-20251002164822.png" target="_self">]]></description><link>images/pasted-image-20251002164822.html</link><guid isPermaLink="false">Images/Pasted image 20251002164822.png</guid><pubDate>Thu, 02 Oct 2025 13:48:22 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20251002164741]]></title><description><![CDATA[<img src="images/pasted-image-20251002164741.png" target="_self">]]></description><link>images/pasted-image-20251002164741.html</link><guid isPermaLink="false">Images/Pasted image 20251002164741.png</guid><pubDate>Thu, 02 Oct 2025 13:47:41 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20251002164032]]></title><description><![CDATA[<img src="images/pasted-image-20251002164032.png" target="_self">]]></description><link>images/pasted-image-20251002164032.html</link><guid isPermaLink="false">Images/Pasted image 20251002164032.png</guid><pubDate>Thu, 02 Oct 2025 13:40:32 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20251002163252]]></title><description><![CDATA[<img src="images/pasted-image-20251002163252.png" target="_self">]]></description><link>images/pasted-image-20251002163252.html</link><guid isPermaLink="false">Images/Pasted image 20251002163252.png</guid><pubDate>Thu, 02 Oct 2025 13:32:52 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[00 Basic Interconnect]]></title><description><![CDATA[
This is more or less a summarization of Chapter 4, of Arm Fundamentals of SoC textbook Requestor &amp; Completer
The Component that is Requesting a resource/computation from another component, the completer, which completes this request.
ARM SoC: Single Word Transaction
The simplest form of transaction that we need an interconnect protocol to support is the movement of a single word from a requestor to a completer, that is, a single-word write transaction.
To Support Single Word Write Transaction we can simply add
The WR signal and the WRDATA are recieved on the same rising edge.
To Support Single Word Write Transaction we can simply add
The RD signal is received at rising edge 0 cycle 0, then the RDDATA on the next rising edge
“Pasted image 20251002163252.png” could not be found.Assumption &amp; disadvantages This assumes the completer can read/execute the request every clock cycle (1) We’ve assumed until now that there is only is one location, that is, only one register, in the completer (2) Asynchronous Reads
nothing prevents an interconnect protocol from permitting read data to be returned during cycle C (and, in fact, many protocols do allow this); however, this would imply that the overall read operation is asynchronous and we have stated that the interconnect we are building is synchronous.
“Pasted image 20251002164032.png” could not be found.A Major Disadvantage with the current interconnect that its support for back-to-back rapid transaction is lack-luster and leaves clock cycles to be optimized.
In the general case of a completer with an N-cycle end-to-end read latency, the maximum data throughput will be: To Mitigate this we can add a LENGTH Control Signal to signal to the completer how much data is given to it to write/read.“Pasted image 20251002164741.png” could not be found.“Pasted image 20251002164822.png” could not be found.We Know <a data-tooltip-position="top" aria-label="^DW2" data-href="#^DW2" href="#^DW2" class="internal-link" target="_self" rel="noopener nofollow">Assumption (1)</a> is not true as the completer may need to process the request for many clock cycles.Terminiology
The mechanism through which a completer communicates its unavailability to a requestor is referred to as backpressure and a requestor waiting on a completer’s acknowledgement in this context is said to be stalled
To realize this feature, all we need is to implement a READY signal.
A transaction starts only when WR/RD and READY are both asserted in the same clock cycle.
Avoid Infinite Requestor Stalling
if a requestor wants to start a transaction, then it should assert its control signals and keep them asserted until the completer’s READY signal is asserted, Two Design Decesions are employed here: the requestor must not check the READY signal before deciding to assert its control signals because otherwise the completer may never know of the requestor’s intention to start a transaction
transactions cannot be interrupted once started because a requestor cannot deassert its control signals early, and all data words must be transmitted for both entities to acknowledge the transaction has finished. “Pasted image 20251002190522.png” could not be found.
Notice That the Completer Asserts/Deasserts the READY signal for each data write B C &amp; D.
Reading from completors may also incur many clock cycles, There needs to be a control signal that registers that the data within the RDDATA bus is valid.For a read transaction, the RD signal does not convey the validity of the RDDATA bus, but rather the validity of the control signals relevant to starting a transaction (ADDR, LENGTH). We need an additional completer-to-requestor signal to convey the validity of the RDDATA bus.
So RDDATAVALID is born: once completer fetches data, the RDDATAVALID, is asserted.
“Pasted image 20251002192210.png” could not be found.<br>Next <a data-href="01 AHB-Lite Protocol" href="root/digital-design/interconnect/01-ahb-lite-protocol.html" class="internal-link" target="_self" rel="noopener nofollow">01 AHB-Lite Protocol</a>]]></description><link>root/digital-design/interconnect/00-basic-interconnect.html</link><guid isPermaLink="false">root/Digital Design/Interconnect/00 Basic Interconnect.md</guid><pubDate>Thu, 02 Oct 2025 16:34:10 GMT</pubDate></item><item><title><![CDATA[Iverilog & GtkWave Simulation]]></title><description><![CDATA[Make Sure your test-bench dumps waveform .vcd in the output, by appending: initial
begin $dumpfile("&lt;module name&gt;_tb.vcd"); $dumpvars(0,test);
end
$ iverilog -o &lt;output_filename&gt; &lt;testbench&gt;.v &lt;verilog_sources&gt;.v $ vvp &lt;output_filename&gt; $ gtkwave &lt;vcd_filename&gt;.vcd &amp;
Directory structure-rw-rw-r-- 1 waseem waseem 939 Oct 2 14:43 ahbl_master_tb.v
-rw-rw-r-- 1 waseem waseem 291 Oct 2 14:43 readme.md
drwxrwxr-x 2 waseem waseem 4.0K Oct 2 14:55 src/
iverilog -o out ahbl_master_tb.v src/ahbl_master.v src/ahbl_slave.v src/ahbl_splitter_4.v
OR you can use -I Option or wildcards *iverilog -o out ahbl_master_tb.v src/*.v
gtkwave &lt;vcd_filename&gt;.vcd &amp;
# Source files
V_SOURCES = $(wildcard src/*.v)
TB_SOURCE = ahbl_master_tb.v # Output files
OUT_FILE = out
# Nasty string concatenation trick to maintain consistency
VCD_FILE = $(TB_SOURCE)cd # Default target: runs the simulation and opens the waveform
all: wave # Compile the Verilog sources
$(OUT_FILE): $(V_SOURCES) $(TB_SOURCE) iverilog -o $(OUT_FILE) $(TB_SOURCE) $(V_SOURCES) # Run the simulation to generate the VCD file
$(VCD_FILE): $(OUT_FILE) vvp $(OUT_FILE) # Target to run the simulation
sim: $(VCD_FILE) # Open the waveform in GTKWave
wave: $(VCD_FILE) gtkwave $(VCD_FILE) &amp; # Clean up generated files
clean: rm -f $(OUT_FILE) $(VCD_FILE)
]]></description><link>root/digital-design/iverilog-&amp;-gtkwave-simulation.html</link><guid isPermaLink="false">root/Digital Design/Iverilog &amp; GtkWave Simulation.md</guid><pubDate>Thu, 02 Oct 2025 16:12:58 GMT</pubDate></item><item><title><![CDATA[GDB]]></title><description><![CDATA[g++ &lt;file-name&gt; -g -o &lt;executable-name&gt;-g debugging symbols
-o output executablerun
lay nextbr &lt;symbol (file,method,variable,line)&gt;info &lt;command&gt;
info break : show breakpoints enable 1 : enable (ID of breakpoint)
disable 1 : disable (ID of breakpoint)Overloaded functions when putting a breakpoint on an overloaded function GDB will put the breakpoints on all the functions of the same name
print &lt;var&gt;
inspect &lt;stl structure&gt;set &lt;var&gt; = &lt;value&gt;nsfincontinue or cneed -lpthread flag when compilinginfo threads or thswitching threads
t &lt;id&gt; backtrace of the thread
btswitching frames
f &lt;id&gt;b &lt;function&gt; if &lt;variable&gt; &lt;operator&gt; &lt;value&gt;break on function if condition met--release and --g flagscompiler optimization flags-03
-02
-01 (Default) -g3 debugging with optimiation level 3
]]></description><link>root/debugging/gdb.html</link><guid isPermaLink="false">root/Debugging/GDB.md</guid><pubDate>Thu, 02 Oct 2025 16:05:14 GMT</pubDate></item><item><title><![CDATA[01 AHB-Lite Protocol]]></title><link>root/digital-design/interconnect/01-ahb-lite-protocol.html</link><guid isPermaLink="false">root/Digital Design/Interconnect/01 AHB-Lite Protocol.md</guid><pubDate>Thu, 02 Oct 2025 13:06:44 GMT</pubDate></item></channel></rss>